//go:build ignore

//go:generate go run bytesconv_table_gen.go

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
)

const (
	toLower = 'a' - 'A'
)

func main() {
	hex2intTable := func() [256]byte {
		var b [256]byte
		for i := 0; i < 256; i++ {
			c := byte(16)
			if i >= '0' && i <= '9' {
				c = byte(i) - '0'
			} else if i >= 'a' && i <= 'f' {
				c = byte(i) - 'a' + 10
			} else if i >= 'A' && i <= 'F' {
				c = byte(i) - 'A' + 10
			}
			b[i] = c
		}
		return b
	}()

	toLowerTable := func() [256]byte {
		var a [256]byte
		for i := 0; i < 256; i++ {
			c := byte(i)
			if c >= 'A' && c <= 'Z' {
				c += toLower
			}
			a[i] = c
		}
		return a
	}()

	toUpperTable := func() [256]byte {
		var a [256]byte
		for i := 0; i < 256; i++ {
			c := byte(i)
			if c >= 'a' && c <= 'z' {
				c -= toLower
			}
			a[i] = c
		}
		return a
	}()

	quotedArgShouldEscapeTable := func() [256]byte {
		// According to RFC 3986 §2.3
		var a [256]byte
		for i := 0; i < 256; i++ {
			a[i] = 1
		}

		// ALPHA
		for i := int('a'); i <= int('z'); i++ {
			a[i] = 0
		}
		for i := int('A'); i <= int('Z'); i++ {
			a[i] = 0
		}

		// DIGIT
		for i := int('0'); i <= int('9'); i++ {
			a[i] = 0
		}

		// Unreserved characters
		for _, v := range `-_.~` {
			a[v] = 0
		}

		return a
	}()

	quotedPathShouldEscapeTable := func() [256]byte {
		// 此处实现等效于 net/url shouldEscape(s, encodePath) 但仅逃逸问号。
		//
		// The RFC allows : @ & = + $ but saves / ; , for assigning
		// meaning to individual path segments. This package
		// only manipulates the path as a whole, so we allow those
		// last three as well. That leaves only ? to escape.
		a := quotedArgShouldEscapeTable

		for _, v := range `$&+,/:;=@` {
			a[v] = 0
		}

		return a
	}()

	validCookieValueTable := func() [256]byte {
		// 此处实现等效于 net/http validCookieValueByte(b byte)
		// see https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1
		var a [256]byte
		for i := 0; i < 256; i++ {
			a[i] = 0
		}

		for i := 0x20; i < 0x7f; i++ {
			a[i] = 1
		}

		a['"'] = 0
		a[';'] = 0
		a['\\'] = 0

		return a
	}()

	validHeaderFieldValueTable := func() [256]byte {
		// The implementation here is equal to httpguts.ValidHeaderFieldValue
		var a [256]byte
		for i := 0; i < 256; i++ {
			a[i] = 1
		}

		for i := 0; i < ' '; i++ {
			a[i] = 0
		}

		// del CTL
		a[0x7f] = 0
		// tab
		a['\t'] = 1

		return a
	}()

	w := new(bytes.Buffer)
	w.WriteString(pre)
	fmt.Fprintf(w, "const (\n")
	fmt.Fprintf(w, "\tHex2intTable = %q\n", hex2intTable)
	fmt.Fprintf(w, "\tToLowerTable = %q\n", toLowerTable)
	fmt.Fprintf(w, "\tToUpperTable = %q\n", toUpperTable)
	fmt.Fprintf(w, "\tQuotedArgShouldEscapeTable = %q\n", quotedArgShouldEscapeTable)
	fmt.Fprintf(w, "\tQuotedPathShouldEscapeTable = %q\n", quotedPathShouldEscapeTable)
	fmt.Fprintf(w, "\tValidCookieValueTable = %q\n", validCookieValueTable)
	fmt.Fprintf(w, "\tValidHeaderFieldValueTable = %q\n", validHeaderFieldValueTable)
	fmt.Fprintf(w, ")\n")

	if err := ioutil.WriteFile("bytesconv_table.go", w.Bytes(), 0o660); err != nil {
		log.Fatal(err)
	}
}

const pre = `package bytesconv

// Code generated by go run bytesconv_table_gen.go; DO NOT EDIT.
// 查看 bytesconv_table_gen.go 获取这些字节转换表的更多信息。

`
